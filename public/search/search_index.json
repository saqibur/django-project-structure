{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#django-project-structure","title":"Django Project Structure","text":"<p>This is a template/project structure for developing django-based applications - either strictly through the <code>django-rest-framework</code> or just <code>django</code>.</p> <p>The project is meant to be easily clone-able, and used as the starter template for the next big thing you develop. Note, this is a folder structure only, not \u201cbest practices\u201d.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<ol> <li>Since this is a template repository, simply hit \"Use this template\" on GitHub and follow the instructions. Otherwise, you can just clone the repo, remove/add anything you see fit.</li> <li>Run the project using <code>python manage.py runserver</code> and you should see the default success page provided by Django at http://127.0.0.1:8000/.</li> </ol>"},{"location":"#creating-an-app","title":"Creating an App","text":"<ol> <li>Create a folder with the app name in <code>apps</code>. For example: <code>poll</code></li> <li>Run <code>python manage.py startapp poll apps/poll</code> from the root directory of the project</li> </ol>"},{"location":"#project-tree","title":"Project Tree","text":"<pre><code>.\n\u251c\u2500\u2500 apps\n\u2502   \u2514\u2500\u2500 example # A django rest app\n\u2502       \u251c\u2500\u2500 api\n\u2502       \u2502   \u251c\u2500\u2500 v1 # Only the \"presentation\" layer exists here.\n\u2502       \u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502       \u2502   \u2502   \u251c\u2500\u2500 serializers.py\n\u2502       \u2502   \u2502   \u251c\u2500\u2500 urls.py\n\u2502       \u2502   \u2502   \u2514\u2500\u2500 views.py\n\u2502       \u2502   \u251c\u2500\u2500 v2 # Only the \"presentation\" layer exists here.\n\u2502       \u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502       \u2502   \u2502   \u251c\u2500\u2500 serializers.py\n\u2502       \u2502   \u2502   \u251c\u2500\u2500 urls.py\n\u2502       \u2502   \u2502   \u2514\u2500\u2500 views.py\n\u2502       \u2502   \u2514\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 fixtures # Constant \"seeders\" to populate your database\n\u2502       \u251c\u2500\u2500 management\n\u2502       \u2502   \u251c\u2500\u2500 commands # Try and write some database seeders here\n\u2502       \u2502   \u2502   \u2514\u2500\u2500 command.py\n\u2502       \u2502   \u2514\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 migrations\n\u2502       \u2502   \u2514\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 templates # App-specific templates go here\n\u2502       \u251c\u2500\u2500 tests # All your integration and unit tests for an app go here.\n\u2502       \u251c\u2500\u2500 admin.py\n\u2502       \u251c\u2500\u2500 apps.py\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 models.py\n\u2502       \u251c\u2500\u2500 services.py # Your business logic and data abstractions go here.\n\u2502       \u251c\u2500\u2500 urls.py\n\u2502       \u2514\u2500\u2500 views.py\n\u251c\u2500\u2500 common # An optional folder containing common \"stuff\" for the entire project\n\u251c\u2500\u2500 config\n\u2502   \u251c\u2500\u2500 settings.py\n\u2502   \u251c\u2500\u2500 asgi.py\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 urls.py\n\u2502   \u2514\u2500\u2500 wsgi.py\n\u251c\u2500\u2500 deployments # Isolate Dockerfiles and docker-compose files here.\n\u251c\u2500\u2500 docs\n\u2502   \u251c\u2500\u2500 CHANGELOG.md\n\u2502   \u251c\u2500\u2500 CONTRIBUTING.md\n\u2502   \u251c\u2500\u2500 deployment.md\n\u2502   \u251c\u2500\u2500 local-development.md\n\u2502   \u2514\u2500\u2500 swagger.yaml\n\u251c\u2500\u2500 requirements\n\u2502   \u251c\u2500\u2500 common.txt # Same for all environments\n\u2502   \u251c\u2500\u2500 development.txt # Only for a development server\n\u2502   \u251c\u2500\u2500 local.txt # Only for a local server (example: docs, performance testing, etc.)\n\u2502   \u2514\u2500\u2500 production.txt # Production only\n\u251c\u2500\u2500 static # Your static files\n\u251c\u2500\u2500 .env.example # An example of your .env configurations. Add necessary comments.\n\u251c\u2500\u2500 static # Your static files\n\u251c\u2500\u2500 .gitignore # https://github.com/github/gitignore/blob/main/Python.gitignore\n\u251c\u2500\u2500 entrypoint.sh # Any bootstrapping necessary for your application\n\u251c\u2500\u2500 manage.py\n\u251c\u2500\u2500 pytest.ini\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"#rationale","title":"Rationale","text":"<p>Each <code>app</code> should be designed in way to be plug-able, that is, dragged and dropped into any other project and it\u2019ll work independently.</p>"},{"location":"#apps-folder","title":"<code>apps</code> Folder","text":"<ul> <li>A mother-folder containing all apps for our project. Congruent to any JS-framework's <code>src</code> folder. If you really wanted to, you could even call it the <code>src</code> folder. Again, it's up to you.</li> <li>An app can be a django template project, or an rest framework API.</li> </ul>"},{"location":"#services","title":"<code>services</code>","text":"<ul> <li>We\u2019ll be writing business logic in services instead of anywhere else.</li> <li>There's a common argument: \"Why not just use model managers?\", and honestly, that's a fair point. However, for our use case, we've often noticed that a single service can leverage more zero to many models. Either way, managers or services, both work towards the same goal - isolating business logic away from views, and brings it closer to the data.</li> </ul>"},{"location":"#api-folder","title":"<code>api</code> Folder","text":"<ul> <li>We like to place all our API components into a package within an app called <code>api</code>. For example, in this repository it's the <code>example/api</code> folder. That allows us to isolate our API components in a consistent location. If we were to put it in the root of our app, then we would end up with a huge list of API-specific modules in the general area of the app. That's without getting into the mess of API versioning.</li> </ul> <p>For projects with a lot of small, interconnecting apps, it can be hard to hunt down where a particular API view lives. In contrast to placing all API code within each relevant app, sometimes it makes more sense to build an app specifically for the API. This is where all the serializers, renderers, and views are placed. Therefore, the name of the app should reflect its API version</p>"},{"location":"#api-versioning","title":"API Versioning","text":"<p>It might often be necessary to support multiple versions of an API throughout the lifetime of a project. Therefore, we're adding in support right from the start.</p> <p>For different API versions, we're assuming the following will change: - Serializers: That is, how the data is presented to a consumer - Views: That is, how the data is accessed and modified by a consumer - URLs: That is, where the consumer access the data</p> <p><code>model</code>s and <code>service</code>s can be thought of as shared between versions. Therefore, migrating changes should be versioned carefully without breaking different versions of the API. After all, your API version is simply a presentation of how data is handled and managed within your application.</p> <p>Sufficient unit tests and integration tests should wrap services and API endpoints to ensure full compatibility.</p>"},{"location":"#whats-v2-of-an-api","title":"What's <code>v2</code> of an API?","text":"<p>Currently we're proposing that major changes to the following, constitutes a new API version: 1. Representation of data, either for submission or retrieval 1. Major optimizations 1. Major code reorganization and code refactor 1. Usually, in a Django project, you won't need to worry about API versioning</p>"},{"location":"#config","title":"<code>config</code>","text":"<ul> <li>Contains project configuration files, including the primary URL file</li> <li>~~Contains settings split into <code>base</code>, <code>local</code>, <code>production</code> and <code>development</code>.~~. Update: As environment specific variables will be handled using environment variables, we've deemed it unnecessary to have separate settings files for now.</li> </ul>"},{"location":"#deployments","title":"<code>deployments</code>","text":"<ul> <li>Contains Docker, Docker-Compose and nginx specific files for deploying in different environments.</li> </ul>"},{"location":"#exception-handling","title":"Exception handling","text":"<p>You should probably add a custom exception handler to your project based on who consumes your APIs. To learn how to create a custom exception handler, you can check out the Django Rest Framework documentation at: https://www.django-rest-framework.org/api-guide/exceptions/#custom-exception-handling</p>"},{"location":"#references","title":"References","text":"<ul> <li>Two Scoops of Django by Daniel and Audrey Feldroy</li> <li>Django Best Practices</li> <li>Cookiecutter Django</li> <li>HackSoft Django Style Guide</li> <li>Radoslav Georgiev - Django Structure for Scale and Longevity</li> <li>Build APIs You Won't Hate</li> <li>Tuxedo Style Guides</li> </ul>"}]}